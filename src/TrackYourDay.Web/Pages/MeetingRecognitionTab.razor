@using TrackYourDay.Core.ApplicationTrackers.MsTeams.Configuration
@using TrackYourDay.Core.ApplicationTrackers.MsTeams.Persistence
@using TrackYourDay.Core.ApplicationTrackers.MsTeams
@inject IMeetingRuleRepository ruleRepository
@inject IProcessService processService
@inject IDialogService dialogService
@inject ISnackbar snackbar

<MudStack Spacing="3">
    <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
        <MudStack Spacing="1">
            <MudText Typo="Typo.h6">Meeting Recognition Rules</MudText>
            <MudText Typo="Typo.body2" Color="Color.Secondary">
                Configure patterns to detect MS Teams meetings. Rules apply immediately (no restart required).
            </MudText>
        </MudStack>
        <MudStack Row="true" Spacing="2">
            <MudButton Variant="Variant.Outlined" 
                       Color="Color.Info" 
                       OnClick="TestRules"
                       StartIcon="@Icons.Material.Filled.BugReport"
                       Disabled="isLoading">
                Test Rules
            </MudButton>
            <MudButton Variant="Variant.Filled" 
                       Color="Color.Primary" 
                       OnClick="AddNewRule"
                       StartIcon="@Icons.Material.Filled.Add"
                       Disabled="isLoading">
                Add Rule
            </MudButton>
        </MudStack>
    </MudStack>

    @if (!string.IsNullOrEmpty(errorMessage))
    {
        <MudAlert Severity="Severity.Error" ShowCloseIcon="true" CloseIconClicked="@(() => errorMessage = string.Empty)">
            @errorMessage
        </MudAlert>
    }

    @if (!string.IsNullOrEmpty(successMessage))
    {
        <MudAlert Severity="Severity.Success" ShowCloseIcon="true" CloseIconClicked="@(() => successMessage = string.Empty)">
            @errorMessage
        </MudAlert>
    }

    <MudDataGrid T="MeetingRecognitionRule" 
                 Items="@rules" 
                 Dense="true"
                 Hover="true"
                 Loading="@isLoading"
                 ReadOnly="false"
                 EditMode="DataGridEditMode.Cell">
        <Columns>
            <PropertyColumn Property="x => x.Priority" Title="Priority" Sortable="false">
                <CellTemplate>
                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                        <MudText>@context.Item.Priority</MudText>
                        <MudStack Spacing="0">
                            <MudIconButton Icon="@Icons.Material.Filled.KeyboardArrowUp" 
                                           Size="Size.Small" 
                                           OnClick="@(() => MovePriorityUp(context.Item))"
                                           Disabled="@(context.Item.Priority == 1)" />
                            <MudIconButton Icon="@Icons.Material.Filled.KeyboardArrowDown" 
                                           Size="Size.Small" 
                                           OnClick="@(() => MovePriorityDown(context.Item))"
                                           Disabled="@(context.Item.Priority == rules.Count)" />
                        </MudStack>
                    </MudStack>
                </CellTemplate>
            </PropertyColumn>
            
            <TemplateColumn Title="Criteria" Sortable="false">
                <CellTemplate>
                    <MudChip Size="Size.Small" Color="Color.Info">@GetCriteriaDisplay(context.Item.Criteria)</MudChip>
                </CellTemplate>
            </TemplateColumn>
            
            <TemplateColumn Title="Process Pattern" Sortable="false">
                <CellTemplate>
                    @if (context.Item.ProcessNamePattern != null)
                    {
                        <MudStack Spacing="0">
                            <MudText Typo="Typo.body2" Class="text-truncate" Style="max-width: 200px;" title="@context.Item.ProcessNamePattern.Pattern">
                                @context.Item.ProcessNamePattern.Pattern
                            </MudText>
                            <MudText Typo="Typo.caption" Color="Color.Secondary">
                                @GetMatchModeDisplay(context.Item.ProcessNamePattern.MatchMode)@(context.Item.ProcessNamePattern.CaseSensitive ? " (case-sensitive)" : "")
                            </MudText>
                        </MudStack>
                    }
                    else
                    {
                        <MudText Typo="Typo.body2" Color="Color.Secondary">—</MudText>
                    }
                </CellTemplate>
            </TemplateColumn>
            
            <TemplateColumn Title="Window Pattern" Sortable="false">
                <CellTemplate>
                    @if (context.Item.WindowTitlePattern != null)
                    {
                        <MudStack Spacing="0">
                            <MudText Typo="Typo.body2" Class="text-truncate" Style="max-width: 200px;" title="@context.Item.WindowTitlePattern.Pattern">
                                @context.Item.WindowTitlePattern.Pattern
                            </MudText>
                            <MudText Typo="Typo.caption" Color="Color.Secondary">
                                @GetMatchModeDisplay(context.Item.WindowTitlePattern.MatchMode)@(context.Item.WindowTitlePattern.CaseSensitive ? " (case-sensitive)" : "")
                            </MudText>
                        </MudStack>
                    }
                    else
                    {
                        <MudText Typo="Typo.body2" Color="Color.Secondary">—</MudText>
                    }
                </CellTemplate>
            </TemplateColumn>
            
            <TemplateColumn Title="Exclusions" Sortable="false">
                <CellTemplate>
                    @if (context.Item.Exclusions.Any())
                    {
                        <MudChip Size="Size.Small" Color="Color.Warning">@context.Item.Exclusions.Count</MudChip>
                    }
                    else
                    {
                        <MudText Typo="Typo.body2" Color="Color.Secondary">None</MudText>
                    }
                </CellTemplate>
            </TemplateColumn>
            
            <TemplateColumn Title="Match Count" Sortable="false">
                <CellTemplate>
                    <MudStack Spacing="0">
                        <MudText Typo="Typo.body2">@context.Item.MatchCount.ToString("N0")</MudText>
                        @if (context.Item.LastMatchedAt.HasValue)
                        {
                            <MudText Typo="Typo.caption" Color="Color.Secondary">
                                @FormatRelativeTime(context.Item.LastMatchedAt.Value)
                            </MudText>
                        }
                    </MudStack>
                </CellTemplate>
            </TemplateColumn>
            
            <TemplateColumn Title="Actions" Sortable="false">
                <CellTemplate>
                    <MudStack Row="true" Spacing="1">
                        <MudIconButton Icon="@Icons.Material.Filled.Edit" 
                                       Size="Size.Small" 
                                       Color="Color.Primary"
                                       OnClick="@(() => EditRule(context.Item))" />
                        <MudIconButton Icon="@Icons.Material.Filled.ContentCopy" 
                                       Size="Size.Small" 
                                       Color="Color.Info"
                                       OnClick="@(() => DuplicateRule(context.Item))" />
                        <MudIconButton Icon="@Icons.Material.Filled.Delete" 
                                       Size="Size.Small" 
                                       Color="Color.Error"
                                       OnClick="@(() => ShowDeleteDialog(context.Item))"
                                       Disabled="@(rules.Count == 1)" />
                    </MudStack>
                </CellTemplate>
            </TemplateColumn>
        </Columns>
    </MudDataGrid>
</MudStack>

@code {
    private List<MeetingRecognitionRule> rules = new();
    private bool isLoading = true;
    private string errorMessage = string.Empty;
    private string successMessage = string.Empty;

    protected override void OnInitialized()
    {
        LoadRules();
    }

    private void LoadRules()
    {
        try
        {
            isLoading = true;
            var loadedRules = ruleRepository.GetAllRules();
            rules = loadedRules.OrderBy(r => r.Priority).ToList();
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to load rules: {ex.Message}";
        }
        finally
        {
            isLoading = false;
        }
    }

    private async Task AddNewRule()
    {
        var parameters = new DialogParameters
        {
            { nameof(RuleEditorDialog.IsEditMode), false },
            { nameof(RuleEditorDialog.Priority), rules.Count + 1 }
        };

        var options = new DialogOptions { MaxWidth = MaxWidth.Large, FullWidth = true };
        var dialog = await dialogService.ShowAsync<RuleEditorDialog>("Add Meeting Recognition Rule", parameters, options);
        var result = await dialog.Result;

        if (!result.Canceled && result.Data is MeetingRecognitionRule newRule)
        {
            try
            {
                rules.Add(newRule);
                SaveRules();
                successMessage = "Rule added successfully. Changes apply immediately.";
            }
            catch (Exception ex)
            {
                errorMessage = $"Failed to add rule: {ex.Message}";
            }
        }
    }

    private async Task EditRule(MeetingRecognitionRule rule)
    {
        var parameters = new DialogParameters
        {
            { nameof(RuleEditorDialog.IsEditMode), true },
            { nameof(RuleEditorDialog.Rule), rule }
        };

        var options = new DialogOptions { MaxWidth = MaxWidth.Large, FullWidth = true };
        var dialog = await dialogService.ShowAsync<RuleEditorDialog>("Edit Meeting Recognition Rule", parameters, options);
        var result = await dialog.Result;

        if (!result.Canceled && result.Data is MeetingRecognitionRule updatedRule)
        {
            try
            {
                var index = rules.FindIndex(r => r.Id == rule.Id);
                if (index >= 0)
                {
                    rules[index] = updatedRule;
                    SaveRules();
                    successMessage = "Rule updated successfully. Changes apply immediately.";
                }
            }
            catch (Exception ex)
            {
                errorMessage = $"Failed to update rule: {ex.Message}";
            }
        }
    }

    private async Task DuplicateRule(MeetingRecognitionRule rule)
    {
        var duplicated = rule with 
        { 
            Id = Guid.NewGuid(), 
            Priority = rules.Count + 1,
            MatchCount = 0,
            LastMatchedAt = null
        };

        var parameters = new DialogParameters
        {
            { nameof(RuleEditorDialog.IsEditMode), false },
            { nameof(RuleEditorDialog.Rule), duplicated }
        };

        var options = new DialogOptions { MaxWidth = MaxWidth.Large, FullWidth = true };
        var dialog = await dialogService.ShowAsync<RuleEditorDialog>("Duplicate Meeting Recognition Rule", parameters, options);
        var result = await dialog.Result;

        if (!result.Canceled && result.Data is MeetingRecognitionRule newRule)
        {
            try
            {
                rules.Add(newRule);
                SaveRules();
                successMessage = "Rule duplicated successfully.";
            }
            catch (Exception ex)
            {
                errorMessage = $"Failed to duplicate rule: {ex.Message}";
            }
        }
    }

    private async Task ShowDeleteDialog(MeetingRecognitionRule rule)
    {
        if (rules.Count == 1)
        {
            snackbar.Add("Cannot delete the only rule. At least one rule must exist.", Severity.Warning);
            return;
        }

        var confirmed = await dialogService.ShowMessageBox(
            "Delete Rule?",
            $"Are you sure you want to delete this rule? This cannot be undone.",
            yesText: "Delete", cancelText: "Cancel");

        if (confirmed == true)
        {
            try
            {
                rules.Remove(rule);
                ReorderPriorities();
                SaveRules();
                successMessage = "Rule deleted successfully.";
            }
            catch (Exception ex)
            {
                errorMessage = $"Failed to delete rule: {ex.Message}";
            }
        }
    }

    private void MovePriorityUp(MeetingRecognitionRule rule)
    {
        var currentIndex = rules.FindIndex(r => r.Id == rule.Id);
        if (currentIndex > 0)
        {
            rules.RemoveAt(currentIndex);
            rules.Insert(currentIndex - 1, rule);
            ReorderPriorities();
            SaveRules();
        }
    }

    private void MovePriorityDown(MeetingRecognitionRule rule)
    {
        var currentIndex = rules.FindIndex(r => r.Id == rule.Id);
        if (currentIndex < rules.Count - 1)
        {
            rules.RemoveAt(currentIndex);
            rules.Insert(currentIndex + 1, rule);
            ReorderPriorities();
            SaveRules();
        }
    }

    private void ReorderPriorities()
    {
        for (int i = 0; i < rules.Count; i++)
        {
            rules[i] = rules[i] with { Priority = i + 1 };
        }
    }

    private void SaveRules()
    {
        try
        {
            ruleRepository.SaveRules(rules);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to save rules: {ex.Message}";
            LoadRules(); // Reload to revert changes
        }
    }

    private async Task TestRules()
    {
        var parameters = new DialogParameters
        {
            { nameof(RuleTestDialog.Rules), rules.AsReadOnly() }
        };

        var options = new DialogOptions { MaxWidth = MaxWidth.ExtraLarge, FullWidth = true };
        await dialogService.ShowAsync<RuleTestDialog>("Test Meeting Recognition Rules", parameters, options);
    }

    private string GetCriteriaDisplay(MatchingCriteria criteria) => criteria switch
    {
        MatchingCriteria.ProcessNameOnly => "Process",
        MatchingCriteria.WindowTitleOnly => "Window",
        MatchingCriteria.Both => "Both",
        _ => criteria.ToString()
    };

    private string GetMatchModeDisplay(PatternMatchMode mode) => mode switch
    {
        PatternMatchMode.Contains => "Contains",
        PatternMatchMode.StartsWith => "Starts with",
        PatternMatchMode.EndsWith => "Ends with",
        PatternMatchMode.Exact => "Exact",
        PatternMatchMode.Regex => "Regex",
        _ => mode.ToString()
    };

    private string FormatRelativeTime(DateTime utcTime)
    {
        var now = DateTime.UtcNow;
        var diff = now - utcTime;

        if (diff.TotalMinutes < 1) return "Just now";
        if (diff.TotalMinutes < 60) return $"{(int)diff.TotalMinutes}m ago";
        if (diff.TotalHours < 24) return $"{(int)diff.TotalHours}h ago";
        if (diff.TotalDays < 7) return $"{(int)diff.TotalDays}d ago";
        
        return utcTime.ToLocalTime().ToString("MMM dd");
    }
}
