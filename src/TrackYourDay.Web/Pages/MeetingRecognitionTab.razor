@using TrackYourDay.Core.ApplicationTrackers.MsTeams.Configuration
@using TrackYourDay.Core.ApplicationTrackers.MsTeams.Persistence
@using TrackYourDay.Core.ApplicationTrackers.MsTeams
@inject IMeetingRuleRepository ruleRepository
@inject IProcessService processService
@inject IDialogService dialogService
@inject ISnackbar snackbar

<MudStack Spacing="3">
    <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
        <MudStack Spacing="1">
            <MudText Typo="Typo.h6">Meeting Recognition Rules</MudText>
            <MudText Typo="Typo.body2" Color="Color.Secondary">
                Configure patterns to detect MS Teams meetings. Rules apply immediately (no restart required).
            </MudText>
        </MudStack>
        <MudStack Row="true" Spacing="2">
            <MudButton Variant="Variant.Outlined" 
                       Color="Color.Info" 
                       OnClick="TestRules"
                       StartIcon="@Icons.Material.Filled.BugReport"
                       Disabled="isLoading">
                Test Rules
            </MudButton>
            <MudButton Variant="Variant.Filled" 
                       Color="Color.Primary" 
                       OnClick="AddNewRule"
                       StartIcon="@Icons.Material.Filled.Add"
                       Disabled="isLoading">
                Add Rule
            </MudButton>
        </MudStack>
    </MudStack>

    @if (!string.IsNullOrEmpty(errorMessage))
    {
        <MudAlert Severity="Severity.Error" ShowCloseIcon="true" CloseIconClicked="@(() => errorMessage = string.Empty)">
            @errorMessage
        </MudAlert>
    }

    @if (!string.IsNullOrEmpty(successMessage))
    {
        <MudAlert Severity="Severity.Success" ShowCloseIcon="true" CloseIconClicked="@(() => successMessage = string.Empty)">
            @errorMessage
        </MudAlert>
    }

    <MudDropContainer T="MeetingRecognitionRule" 
                      Items="@rules" 
                      ItemsSelector="@((item, dropzone) => true)"
                      ItemDropped="OnItemDropped"
                      Class="d-flex flex-column">
        <ChildContent>
            <MudPaper Elevation="0" Class="pa-2 mb-2" Style="background-color: var(--mud-palette-background-grey);">
                <MudGrid Spacing="2">
                    <MudItem xs="1">
                        <MudText Typo="Typo.subtitle2">Priority</MudText>
                    </MudItem>
                    <MudItem xs="2">
                        <MudText Typo="Typo.subtitle2">Criteria</MudText>
                    </MudItem>
                    <MudItem xs="3">
                        <MudText Typo="Typo.subtitle2">Process Pattern</MudText>
                    </MudItem>
                    <MudItem xs="3">
                        <MudText Typo="Typo.subtitle2">Window Pattern</MudText>
                    </MudItem>
                    <MudItem xs="1">
                        <MudText Typo="Typo.subtitle2">Exclusions</MudText>
                    </MudItem>
                    <MudItem xs="1">
                        <MudText Typo="Typo.subtitle2">Matches</MudText>
                    </MudItem>
                    <MudItem xs="1">
                        <MudText Typo="Typo.subtitle2" Align="Align.End">Actions</MudText>
                    </MudItem>
                </MudGrid>
            </MudPaper>
            
            <MudDropZone T="MeetingRecognitionRule" Identifier="rules-zone" Class="flex-grow-1">
                @if (isLoading)
                {
                    <MudProgressLinear Indeterminate="true" />
                }
                else if (!rules.Any())
                {
                    <MudAlert Severity="Severity.Info">
                        No rules configured. Click "Add Rule" to create your first meeting recognition rule.
                    </MudAlert>
                }
            </MudDropZone>
        </ChildContent>
        <ItemRenderer>
            <MudPaper Elevation="2" Class="pa-3 mb-2 mud-ripple draggable-rule" Style="cursor: grab;">
                <MudGrid Spacing="2" Justify="Justify.SpaceBetween">
                    <MudItem xs="1">
                        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                            <MudIcon Icon="@Icons.Material.Filled.DragIndicator" Size="Size.Small" />
                            <MudText Typo="Typo.body1">@context.Priority</MudText>
                            <MudStack Spacing="0">
                                <MudIconButton Icon="@Icons.Material.Filled.KeyboardArrowUp" 
                                               Size="Size.Small" 
                                               OnClick="@(() => MovePriorityUp(context))"
                                               Disabled="@(context.Priority == 1)" />
                                <MudIconButton Icon="@Icons.Material.Filled.KeyboardArrowDown" 
                                               Size="Size.Small" 
                                               OnClick="@(() => MovePriorityDown(context))"
                                               Disabled="@(context.Priority == rules.Count)" />
                            </MudStack>
                        </MudStack>
                    </MudItem>
                    
                    <MudItem xs="2">
                        <MudChip Size="Size.Small" Color="Color.Info">@GetCriteriaDisplay(context.Criteria)</MudChip>
                    </MudItem>
                    
                    <MudItem xs="3">
                        @if (context.ProcessNamePattern != null)
                        {
                            <MudStack Spacing="0">
                                <MudText Typo="Typo.body2" Class="text-truncate" Style="max-width: 250px;" title="@context.ProcessNamePattern.Pattern">
                                    @context.ProcessNamePattern.Pattern
                                </MudText>
                                <MudText Typo="Typo.caption" Color="Color.Secondary">
                                    @GetMatchModeDisplay(context.ProcessNamePattern.MatchMode)@(context.ProcessNamePattern.CaseSensitive ? " (case-sensitive)" : "")
                                </MudText>
                            </MudStack>
                        }
                        else
                        {
                            <MudText Typo="Typo.body2" Color="Color.Secondary">—</MudText>
                        }
                    </MudItem>
                    
                    <MudItem xs="3">
                        @if (context.WindowTitlePattern != null)
                        {
                            <MudStack Spacing="0">
                                <MudText Typo="Typo.body2" Class="text-truncate" Style="max-width: 250px;" title="@context.WindowTitlePattern.Pattern">
                                    @context.WindowTitlePattern.Pattern
                                </MudText>
                                <MudText Typo="Typo.caption" Color="Color.Secondary">
                                    @GetMatchModeDisplay(context.WindowTitlePattern.MatchMode)@(context.WindowTitlePattern.CaseSensitive ? " (case-sensitive)" : "")
                                </MudText>
                            </MudStack>
                        }
                        else
                        {
                            <MudText Typo="Typo.body2" Color="Color.Secondary">—</MudText>
                        }
                    </MudItem>
                    
                    <MudItem xs="1">
                        @if (context.Exclusions.Any())
                        {
                            <MudChip Size="Size.Small" Color="Color.Warning">@context.Exclusions.Count</MudChip>
                        }
                        else
                        {
                            <MudText Typo="Typo.body2" Color="Color.Secondary">None</MudText>
                        }
                    </MudItem>
                    
                    <MudItem xs="1">
                        <MudStack Spacing="0">
                            <MudText Typo="Typo.body2">@context.MatchCount.ToString("N0")</MudText>
                            @if (context.LastMatchedAt.HasValue)
                            {
                                <MudText Typo="Typo.caption" Color="Color.Secondary">
                                    @FormatRelativeTime(context.LastMatchedAt.Value)
                                </MudText>
                            }
                        </MudStack>
                    </MudItem>
                    
                    <MudItem xs="1">
                        <MudStack Row="true" Spacing="1" Justify="Justify.FlexEnd">
                            <MudIconButton Icon="@Icons.Material.Filled.Edit" 
                                           Size="Size.Small" 
                                           Color="Color.Primary"
                                           OnClick="@(() => EditRule(context))" />
                            <MudIconButton Icon="@Icons.Material.Filled.ContentCopy" 
                                           Size="Size.Small" 
                                           Color="Color.Info"
                                           OnClick="@(() => DuplicateRule(context))" />
                            <MudIconButton Icon="@Icons.Material.Filled.Delete" 
                                           Size="Size.Small" 
                                           Color="Color.Error"
                                           OnClick="@(() => ShowDeleteDialog(context))"
                                           Disabled="@(rules.Count == 1)" />
                        </MudStack>
                    </MudItem>
                </MudGrid>
            </MudPaper>
        </ItemRenderer>
    </MudDropContainer>
</MudStack>

@code {
    private List<MeetingRecognitionRule> rules = new();
    private bool isLoading = true;
    private string errorMessage = string.Empty;
    private string successMessage = string.Empty;

    protected override void OnInitialized()
    {
        LoadRules();
    }

    private void LoadRules()
    {
        try
        {
            isLoading = true;
            var loadedRules = ruleRepository.GetAllRules();
            rules = loadedRules.OrderBy(r => r.Priority).ToList();
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to load rules: {ex.Message}";
        }
        finally
        {
            isLoading = false;
        }
    }

    private async Task AddNewRule()
    {
        var parameters = new DialogParameters
        {
            { nameof(RuleEditorDialog.IsEditMode), false },
            { nameof(RuleEditorDialog.Priority), rules.Count + 1 }
        };

        var options = new DialogOptions { MaxWidth = MaxWidth.Large, FullWidth = true };
        var dialog = await dialogService.ShowAsync<RuleEditorDialog>("Add Meeting Recognition Rule", parameters, options);
        var result = await dialog.Result;

        if (!result.Canceled && result.Data is MeetingRecognitionRule newRule)
        {
            try
            {
                rules.Add(newRule);
                SaveRules();
                successMessage = "Rule added successfully. Changes apply immediately.";
            }
            catch (Exception ex)
            {
                errorMessage = $"Failed to add rule: {ex.Message}";
            }
        }
    }

    private async Task EditRule(MeetingRecognitionRule rule)
    {
        var parameters = new DialogParameters
        {
            { nameof(RuleEditorDialog.IsEditMode), true },
            { nameof(RuleEditorDialog.Rule), rule }
        };

        var options = new DialogOptions { MaxWidth = MaxWidth.Large, FullWidth = true };
        var dialog = await dialogService.ShowAsync<RuleEditorDialog>("Edit Meeting Recognition Rule", parameters, options);
        var result = await dialog.Result;

        if (!result.Canceled && result.Data is MeetingRecognitionRule updatedRule)
        {
            try
            {
                var index = rules.FindIndex(r => r.Id == rule.Id);
                if (index >= 0)
                {
                    rules[index] = updatedRule;
                    SaveRules();
                    successMessage = "Rule updated successfully. Changes apply immediately.";
                }
            }
            catch (Exception ex)
            {
                errorMessage = $"Failed to update rule: {ex.Message}";
            }
        }
    }

    private async Task DuplicateRule(MeetingRecognitionRule rule)
    {
        var duplicated = rule with 
        { 
            Id = Guid.NewGuid(), 
            Priority = rules.Count + 1,
            MatchCount = 0,
            LastMatchedAt = null
        };

        var parameters = new DialogParameters
        {
            { nameof(RuleEditorDialog.IsEditMode), false },
            { nameof(RuleEditorDialog.Rule), duplicated }
        };

        var options = new DialogOptions { MaxWidth = MaxWidth.Large, FullWidth = true };
        var dialog = await dialogService.ShowAsync<RuleEditorDialog>("Duplicate Meeting Recognition Rule", parameters, options);
        var result = await dialog.Result;

        if (!result.Canceled && result.Data is MeetingRecognitionRule newRule)
        {
            try
            {
                rules.Add(newRule);
                SaveRules();
                successMessage = "Rule duplicated successfully.";
            }
            catch (Exception ex)
            {
                errorMessage = $"Failed to duplicate rule: {ex.Message}";
            }
        }
    }

    private async Task ShowDeleteDialog(MeetingRecognitionRule rule)
    {
        if (rules.Count == 1)
        {
            snackbar.Add("Cannot delete the only rule. At least one rule must exist.", Severity.Warning);
            return;
        }

        var confirmed = await dialogService.ShowMessageBox(
            "Delete Rule?",
            $"Are you sure you want to delete this rule? This cannot be undone.",
            yesText: "Delete", cancelText: "Cancel");

        if (confirmed == true)
        {
            try
            {
                rules.Remove(rule);
                ReorderPriorities();
                SaveRules();
                successMessage = "Rule deleted successfully.";
            }
            catch (Exception ex)
            {
                errorMessage = $"Failed to delete rule: {ex.Message}";
            }
        }
    }

    private void MovePriorityUp(MeetingRecognitionRule rule)
    {
        var currentIndex = rules.FindIndex(r => r.Id == rule.Id);
        if (currentIndex > 0)
        {
            rules.RemoveAt(currentIndex);
            rules.Insert(currentIndex - 1, rule);
            ReorderPriorities();
            SaveRules();
        }
    }

    private void MovePriorityDown(MeetingRecognitionRule rule)
    {
        var currentIndex = rules.FindIndex(r => r.Id == rule.Id);
        if (currentIndex < rules.Count - 1)
        {
            rules.RemoveAt(currentIndex);
            rules.Insert(currentIndex + 1, rule);
            ReorderPriorities();
            SaveRules();
        }
    }

    private void ReorderPriorities()
    {
        for (int i = 0; i < rules.Count; i++)
        {
            rules[i] = rules[i] with { Priority = i + 1 };
        }
    }

    private void OnItemDropped(MudItemDropInfo<MeetingRecognitionRule> dropInfo)
    {
        if (dropInfo.Item == null) return;

        var item = dropInfo.Item;
        rules.Remove(item);
        
        // Insert at new position based on drop index
        var newIndex = dropInfo.IndexInZone;
        if (newIndex >= rules.Count)
        {
            rules.Add(item);
        }
        else
        {
            rules.Insert(newIndex, item);
        }
        
        ReorderPriorities();
        SaveRules();
    }

    private void SaveRules()
    {
        try
        {
            ruleRepository.SaveRules(rules);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to save rules: {ex.Message}";
            LoadRules(); // Reload to revert changes
        }
    }

    private async Task TestRules()
    {
        var parameters = new DialogParameters
        {
            { nameof(RuleTestDialog.Rules), rules.AsReadOnly() }
        };

        var options = new DialogOptions { MaxWidth = MaxWidth.ExtraLarge, FullWidth = true };
        await dialogService.ShowAsync<RuleTestDialog>("Test Meeting Recognition Rules", parameters, options);
    }

    private string GetCriteriaDisplay(MatchingCriteria criteria) => criteria switch
    {
        MatchingCriteria.ProcessNameOnly => "Process",
        MatchingCriteria.WindowTitleOnly => "Window",
        MatchingCriteria.Both => "Both",
        _ => criteria.ToString()
    };

    private string GetMatchModeDisplay(PatternMatchMode mode) => mode switch
    {
        PatternMatchMode.Contains => "Contains",
        PatternMatchMode.StartsWith => "Starts with",
        PatternMatchMode.EndsWith => "Ends with",
        PatternMatchMode.Exact => "Exact",
        PatternMatchMode.Regex => "Regex",
        _ => mode.ToString()
    };

    private string FormatRelativeTime(DateTime utcTime)
    {
        var now = DateTime.UtcNow;
        var diff = now - utcTime;

        if (diff.TotalMinutes < 1) return "Just now";
        if (diff.TotalMinutes < 60) return $"{(int)diff.TotalMinutes}m ago";
        if (diff.TotalHours < 24) return $"{(int)diff.TotalHours}h ago";
        if (diff.TotalDays < 7) return $"{(int)diff.TotalDays}d ago";
        
        return utcTime.ToLocalTime().ToString("MMM dd");
    }
}
