@page "/analytics"
@using TrackYourDay.Core.Insights.Analytics
@using TrackYourDay.Core.SystemTrackers
@using TrackYourDay.Core.ApplicationTrackers.MsTeams
@using TrackYourDay.Core.ApplicationTrackers.UserTasks
@using TrackYourDay.Core
@using TrackYourDay.Core.Persistence
@using TrackYourDay.Core.Persistence.Specifications
@inject ActivitiesAnalyser activitiesAnalyser
@inject IServiceProvider serviceProvider
@inject IHistoricalDataRepository<EndedActivity> activityRepository
@inject IHistoricalDataRepository<EndedMeeting> meetingRepository
@inject UserTaskService userTaskService
@inject IClock clock

<MudStack Spacing="2">
    <MudGrid>
        <MudItem xs="3">
            <MudDatePicker Label="Start Date" @bind-Date="startDate" />
        </MudItem>
        <MudItem xs="3">
            <MudDatePicker Label="End Date" @bind-Date="endDate" />
        </MudItem>
        <MudItem xs="4">
            <MudSelect T="string" @bind-Value="selectedStrategy" Label="Summary Strategy" Variant="Variant.Outlined"  Class="mud-input-control">
                @foreach (var strategy in availableStrategies)
                {
                    <MudSelectItem Value="@strategy.Key">@strategy.Value.StrategyName</MudSelectItem>
                }
            </MudSelect>
        </MudItem>
        <MudItem xs="2">
            <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="GenerateSummary">Generate</MudButton>
        </MudItem>
    </MudGrid>
    
    @if (!string.IsNullOrEmpty(errorMessage))
    {
        <MudAlert Severity="Severity.Warning">@errorMessage</MudAlert>
    }
    <MudDataGrid T="GroupedActivity" Items="@groupedActivities" SortMode="SortMode.Multiple" Filterable="true" QuickFilter="@_quickFilter" Hideable="false">
        <ToolBarContent>
            <MudTextField @bind-Value="_searchString" Placeholder="Search" Adornment="Adornment.Start" Immediate="true"
                            AdornmentIcon="@Icons.Material.Filled.Search" IconSize="Size.Medium" Class="mt-0"></MudTextField>
        </ToolBarContent>
        <Columns>
            <PropertyColumn Property="x => x.Date.ToShortDateString()" Title="Date" Filterable="false" />
            <PropertyColumn Property="x => x.Duration" Title="Duration" Filterable="true" SortBy="@_sortByDuration"/>
            <PropertyColumn Property="x => x.Description" Title="Description" Filterable="true" SortBy="@_sortByDescritpion" />
        </Columns>
        <PagerContent>
            <MudDataGridPager T="GroupedActivity" />
        </PagerContent>
    </MudDataGrid>    
</MudStack>

@code {
    private List<GroupedActivity>? groupedActivities = null;
    private string selectedStrategy = "Choose strategy";
    private Dictionary<string, ISummaryStrategy> availableStrategies;
    private DateTime? startDate;
    private DateTime? endDate;
    private string errorMessage = string.Empty;

    protected override async Task OnInitializedAsync()
    {
        var strategies = ActivitiesAnalyser.GetAvailableStrategies(serviceProvider);
        availableStrategies = strategies.ToDictionary(s => s.GetType().Name, s => s);
        
        // Set default dates to today
        startDate = clock.Now.Date;
        endDate = clock.Now.Date;
        
        // Do not generate summary on load
    }

    private async Task GenerateSummary()
    {
        errorMessage = string.Empty;
        
        if (startDate == null)
        {
            errorMessage = "Please select a start date.";
            return;
        }
        
        if (endDate == null)
        {
            errorMessage = "Please select an end date.";
            return;
        }
        
        if (string.IsNullOrEmpty(selectedStrategy) || selectedStrategy == "Choose strategy")
        {
            errorMessage = "Please select a summary strategy.";
            return;
        }
        
        if (startDate.Value > endDate.Value)
        {
            errorMessage = "Start date must be before or equal to end date.";
            return;
        }

        ISummaryStrategy strategyInstance = availableStrategies[selectedStrategy];
        
        // Collect all trackable items for the date range
        var allItems = new List<TrackableItem>();
        
        // Get activities from the repository
        var activities = activityRepository.Find(
            new ActivityByDateRangeSpecification(
                DateOnly.FromDateTime(startDate.Value),
                DateOnly.FromDateTime(endDate.Value)));
        allItems.AddRange(activities);
        
        // Get meetings from the repository
        var meetings = meetingRepository.Find(
            new MeetingByDateRangeSpecification(
                DateOnly.FromDateTime(startDate.Value),
                DateOnly.FromDateTime(endDate.Value)));
        allItems.AddRange(meetings);
        
        // Get user tasks from the service
        var userTasks = userTaskService.GetAllTasks()
            .Where(t => t.IsCompleted && 
                       DateOnly.FromDateTime(t.StartDate) >= DateOnly.FromDateTime(startDate.Value) &&
                       DateOnly.FromDateTime(t.StartDate) <= DateOnly.FromDateTime(endDate.Value));
        allItems.AddRange(userTasks);
        
        // Generate grouped activities using the strategy
        groupedActivities = strategyInstance.Generate(allItems)
            .OrderByDescending(activity => activity.Duration)
            .ToList();
        
        await InvokeAsync(StateHasChanged);
    }
    
    private string _searchString;

    private Func<GroupedActivity, object> _sortByDuration => x => x.Duration;
    private Func<GroupedActivity, object> _sortByDescritpion => x => x.Description;
    private Func<GroupedActivity, bool> _quickFilter => x =>
    {
        if (string.IsNullOrWhiteSpace(_searchString))
            return true;
        if (x.Description.Contains(_searchString, StringComparison.OrdinalIgnoreCase))
            return true;
        return false;
    };
}
